<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Night Hunter’s Stand</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Trebuchet MS", "Segoe UI", sans-serif;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: radial-gradient(circle at top, #1b1b2f, #0d0d14 65%);
            overflow: hidden;
        }
        #game-wrapper {
            position: relative;
            width: min(92vw, 1280px);
            aspect-ratio: 16 / 9;
            max-height: 90vh;
        }
        canvas {
            width: 100%;
            height: 100%;
            background: #14141f;
            border: 2px solid #2e2e3d;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
            image-rendering: pixelated;
        }
        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 15, 0.75);
            color: #f8f6f0;
            text-align: center;
            padding: 24px;
            gap: 18px;
        }
        .overlay.hidden {
            display: none;
        }
        .overlay h1 {
            margin: 0;
            font-size: clamp(2rem, 3vw, 3.5rem);
            letter-spacing: 0.05em;
        }
        .overlay p {
            margin: 0;
            max-width: 560px;
            line-height: 1.5;
            color: #d4d1ff;
        }
        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 12px 20px;
            border-radius: 999px;
            border: 1px solid #7c6cff;
            background: linear-gradient(135deg, #6b5cff, #a18bff);
            color: #0d0d14;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(99, 76, 255, 0.35);
        }
        button.secondary {
            background: transparent;
            border-color: #9c9bb8;
            color: #f8f6f0;
        }
        .upgrade-card {
            width: min(240px, 80vw);
            padding: 14px 16px;
            border-radius: 14px;
            border: 1px solid #494970;
            background: rgba(20, 20, 35, 0.9);
            color: #f8f6f0;
        }
        .upgrade-card h3 {
            margin-top: 0;
        }
        .badge {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(124, 108, 255, 0.2);
            border: 1px solid rgba(124, 108, 255, 0.4);
            font-size: 0.75rem;
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <canvas id="gameCanvas" width="1280" height="720"></canvas>

        <div id="start-screen" class="overlay">
            <h1>Night Hunter’s Stand</h1>
            <p>
                Survive the cursed night, gather relics, and evolve your arsenal. Move with
                <strong>WASD</strong> or hold the <strong>mouse/touch</strong> to travel. Level up to pick
                new weapons and upgrades. Clear all stages to banish the ancient evil.
            </p>
            <div class="button-row">
                <button id="start-button">Start Hunt</button>
                <button id="how-button" class="secondary">Controls</button>
            </div>
            <p class="badge">Using CC0 Project Cordon Sprites loaded remotely for characters and terrain.</p>
        </div>

        <div id="upgrade-screen" class="overlay hidden">
            <h1>Choose an Upgrade</h1>
            <p>Pick one blessing to survive the next wave.</p>
            <div id="upgrade-options" class="button-row"></div>
        </div>

        <div id="end-screen" class="overlay hidden">
            <h1 id="end-title">Night Falls</h1>
            <p id="end-message">The night swallows the valley.</p>
            <div class="button-row">
                <button id="restart-button">Restart</button>
                <button id="back-button" class="secondary">Back to Menu</button>
            </div>
        </div>

        <div id="how-screen" class="overlay hidden">
            <h1>Controls</h1>
            <p>
                <strong>Movement:</strong> W/A/S/D or hold mouse/touch to move toward the cursor.<br />
                <strong>Auto Attack:</strong> Your weapons fire automatically. Keep moving!<br />
                <strong>Obstacles:</strong> Ruins and relics block both heroes and monsters, and can stop projectiles.
            </p>
            <button id="close-how">Back</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const upgradeOptions = document.getElementById('upgrade-options');
        const endScreen = document.getElementById('end-screen');
        const endTitle = document.getElementById('end-title');
        const endMessage = document.getElementById('end-message');
        const howScreen = document.getElementById('how-screen');

        const startButton = document.getElementById('start-button');
        const howButton = document.getElementById('how-button');
        const closeHowButton = document.getElementById('close-how');
        const restartButton = document.getElementById('restart-button');
        const backButton = document.getElementById('back-button');

        const keys = {};
        window.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });

        const pointer = {
            active: false,
            x: 0,
            y: 0
        };

        function updatePointerPosition(event) {
            const rect = canvas.getBoundingClientRect();
            pointer.x = (event.clientX - rect.left) * (canvas.width / rect.width);
            pointer.y = (event.clientY - rect.top) * (canvas.height / rect.height);
        }

        canvas.addEventListener('mousedown', (event) => {
            pointer.active = true;
            updatePointerPosition(event);
        });
        canvas.addEventListener('mousemove', (event) => {
            if (!pointer.active) return;
            updatePointerPosition(event);
        });
        canvas.addEventListener('mouseup', () => {
            pointer.active = false;
        });
        canvas.addEventListener('mouseleave', () => {
            pointer.active = false;
        });

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault();
            pointer.active = true;
            updatePointerPosition(event.touches[0]);
        }, { passive: false });
        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            updatePointerPosition(event.touches[0]);
        }, { passive: false });
        canvas.addEventListener('touchend', () => {
            pointer.active = false;
        });

        const gameState = {
            running: false,
            paused: false,
            over: false,
            won: false,
            lastTimestamp: 0,
            stageIndex: 0,
            stageTimer: 0,
            totalTime: 0,
            difficulty: 1
        };

        const stages = [
            { name: 'Forsaken Meadow', duration: 60, spawnRate: 1.1, enemyPool: ['slime', 'goblin'] },
            { name: 'Cursed Village', duration: 80, spawnRate: 0.95, enemyPool: ['goblin', 'skeleton', 'harpy'] },
            { name: 'Graveyard of Kings', duration: 90, spawnRate: 0.8, enemyPool: ['skeleton', 'wraith', 'ogre'] },
            { name: 'Blood Cathedral', duration: 100, spawnRate: 0.7, enemyPool: ['wraith', 'vampire', 'lich'] },
            { name: 'Eclipse Sanctum', duration: 120, spawnRate: 0.55, enemyPool: ['vampire', 'lich', 'dragon'] }
        ];

        const obstacles = [
            { x: 180, y: 120, width: 180, height: 120, type: 'ruins' },
            { x: 840, y: 120, width: 210, height: 130, type: 'monolith' },
            { x: 140, y: 460, width: 220, height: 140, type: 'forest' },
            { x: 760, y: 460, width: 240, height: 150, type: 'crypt' },
            { x: 520, y: 260, width: 120, height: 200, type: 'altar' }
        ];

        const assets = {
            images: {},
            patterns: {},
            ready: false
        };

        const assetManifest = {
            player: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/army-helmet.png',
            enemySlime: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/alien-mask.png',
            enemyGoblin: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/frankensteinmask.png',
            enemySkeleton: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/ghost-mask.png',
            enemyHarpy: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/jack-o-lantern-mask.png',
            enemyWraith: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/demon-mask.png',
            enemyOgre: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/army-helmet.png',
            enemyVampire: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/jack-o-lantern-mask.png',
            enemyLich: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/ghost-mask.png',
            enemyDragon: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/armors/demon-mask.png',
            tileGrass: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/tiles/grass.png',
            tileGrassDark: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/tiles/grass3.png',
            tileGravel: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/tiles/gravel.png',
            tileCement: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/tiles/cement.png',
            treePine: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/trees/pine.png',
            treeWillow: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/trees/willow.png',
            xpFlask: 'https://raw.githubusercontent.com/doficia/project-cordon-sprites/master/sprites/consumables/flask.png'
        };

        function loadImage(key, src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve({ key, img });
                img.onerror = () => reject(new Error(`Failed to load ${src}`));
                img.src = src;
            });
        }

        async function loadAssets() {
            const entries = Object.entries(assetManifest);
            const results = await Promise.all(entries.map(([key, src]) => loadImage(key, src)));
            results.forEach(({ key, img }) => {
                assets.images[key] = img;
            });

            assets.patterns = {
                ruins: ctx.createPattern(assets.images.tileCement, 'repeat'),
                monolith: ctx.createPattern(assets.images.tileGravel, 'repeat'),
                forest: ctx.createPattern(assets.images.tileGrass, 'repeat'),
                crypt: ctx.createPattern(assets.images.tileGrassDark, 'repeat'),
                altar: ctx.createPattern(assets.images.tileCement, 'repeat')
            };
            assets.ready = true;
        }

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            speed: 170,
            maxHp: 100,
            hp: 100,
            level: 1,
            xp: 0,
            xpToLevel: 50,
            armor: 0,
            damageMultiplier: 1,
            projectileSpeed: 1,
            regenTimer: 0,
            weapons: {
                hunterBolt: { level: 1, cooldown: 0.65, timer: 0 },
                arcaneOrb: { level: 0, cooldown: 1.8, timer: 0 },
                holyBoomerang: { level: 0, cooldown: 2.2, timer: 0 },
                daggerWave: { level: 0, cooldown: 2.8, timer: 0 }
            }
        };

        const enemyTypes = {
            slime: { hp: 6, speed: 45, damage: 8, radius: 18, xp: 8, spriteKey: 'enemySlime' },
            goblin: { hp: 10, speed: 65, damage: 10, radius: 19, xp: 12, spriteKey: 'enemyGoblin' },
            skeleton: { hp: 16, speed: 60, damage: 14, radius: 19, xp: 16, spriteKey: 'enemySkeleton' },
            harpy: { hp: 14, speed: 90, damage: 12, radius: 18, xp: 18, spriteKey: 'enemyHarpy', ranged: true },
            wraith: { hp: 22, speed: 70, damage: 18, radius: 20, xp: 24, spriteKey: 'enemyWraith' },
            ogre: { hp: 40, speed: 40, damage: 24, radius: 24, xp: 40, spriteKey: 'enemyOgre' },
            vampire: { hp: 32, speed: 80, damage: 22, radius: 20, xp: 36, spriteKey: 'enemyVampire', dash: true },
            lich: { hp: 42, speed: 55, damage: 26, radius: 21, xp: 50, spriteKey: 'enemyLich', caster: true },
            dragon: { hp: 80, speed: 50, damage: 35, radius: 30, xp: 90, boss: true, spriteKey: 'enemyDragon' }
        };

        const enemies = [];
        const projectiles = [];
        const enemyProjectiles = [];
        const xpOrbs = [];

        const upgradePool = [
            {
                id: 'hunterBolt',
                name: 'Hunter Bolt',
                description: 'Increase bolt damage and fire rate.',
                type: 'weapon'
            },
            {
                id: 'arcaneOrb',
                name: 'Arcane Orb',
                description: 'Add a slow, heavy orb that splashes damage.',
                type: 'weapon'
            },
            {
                id: 'holyBoomerang',
                name: 'Holy Boomerang',
                description: 'Summon a spinning blade that returns to you.',
                type: 'weapon'
            },
            {
                id: 'daggerWave',
                name: 'Dagger Wave',
                description: 'Release daggers in all directions.',
                type: 'weapon'
            },
            {
                id: 'vitality',
                name: 'Vitality Rune',
                description: 'Increase maximum HP and heal 20%.',
                type: 'stat'
            },
            {
                id: 'swiftness',
                name: 'Swiftness Sigil',
                description: 'Move faster and dash through enemies briefly.',
                type: 'stat'
            },
            {
                id: 'focus',
                name: 'Focus Lens',
                description: 'Projectiles fly faster and pierce an extra target.',
                type: 'stat'
            },
            {
                id: 'guard',
                name: 'Guardian Charm',
                description: 'Gain armor and passive regeneration.',
                type: 'stat'
            }
        ];

        function resetGameState() {
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.hp = player.maxHp;
            player.level = 1;
            player.xp = 0;
            player.xpToLevel = 50;
            player.damageMultiplier = 1;
            player.projectileSpeed = 1;
            player.armor = 0;
            player.speed = 170;
            player.regenTimer = 0;
            Object.keys(player.weapons).forEach((key) => {
                player.weapons[key].level = key === 'hunterBolt' ? 1 : 0;
                player.weapons[key].timer = 0;
            });

            enemies.length = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            xpOrbs.length = 0;

            gameState.running = true;
            gameState.paused = false;
            gameState.over = false;
            gameState.won = false;
            gameState.lastTimestamp = 0;
            gameState.stageIndex = 0;
            gameState.stageTimer = 0;
            gameState.totalTime = 0;
            gameState.difficulty = 1;
        }

        function spawnEnemy() {
            const stage = stages[gameState.stageIndex];
            if (!stage) return;
            const type = stage.enemyPool[Math.floor(Math.random() * stage.enemyPool.length)];
            const template = enemyTypes[type];
            const edge = Math.floor(Math.random() * 4);
            let x = 0;
            let y = 0;
            if (edge === 0) { x = Math.random() * canvas.width; y = -40; }
            if (edge === 1) { x = canvas.width + 40; y = Math.random() * canvas.height; }
            if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 40; }
            if (edge === 3) { x = -40; y = Math.random() * canvas.height; }

            enemies.push({
                type,
                x,
                y,
                hp: template.hp,
                speed: template.speed,
                damage: template.damage,
                radius: template.radius,
                xp: template.xp,
                spriteKey: template.spriteKey,
                ranged: template.ranged || false,
                dash: template.dash || false,
                caster: template.caster || false,
                boss: template.boss || false,
                attackTimer: Math.random() * 2
            });
        }

        function spawnBoss() {
            const type = 'dragon';
            const template = enemyTypes[type];
            enemies.push({
                type,
                x: canvas.width / 2,
                y: -60,
                hp: template.hp,
                speed: template.speed,
                damage: template.damage,
                radius: template.radius,
                xp: template.xp,
                spriteKey: template.spriteKey,
                boss: true,
                attackTimer: 0
            });
        }

        function spawnXpOrb(x, y, value) {
            xpOrbs.push({ x, y, value, radius: 6 + Math.min(10, value / 5) });
        }

        function applyUpgrade(upgradeId) {
            const weapon = player.weapons[upgradeId];
            if (weapon) {
                weapon.level += 1;
                if (weapon.level === 1 && upgradeId !== 'hunterBolt') {
                    weapon.timer = 0;
                }
                if (upgradeId === 'hunterBolt') {
                    player.damageMultiplier += 0.15;
                }
                return;
            }

            switch (upgradeId) {
                case 'vitality':
                    player.maxHp += 20;
                    player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.2);
                    break;
                case 'swiftness':
                    player.speed += 15;
                    break;
                case 'focus':
                    player.projectileSpeed += 0.15;
                    break;
                case 'guard':
                    player.armor = Math.min(30, player.armor + 5);
                    break;
                default:
                    break;
            }
        }

        function openUpgradeScreen() {
            gameState.paused = true;
            upgradeOptions.innerHTML = '';
            const choices = [];
            const pool = [...upgradePool];
            while (choices.length < 3 && pool.length > 0) {
                const index = Math.floor(Math.random() * pool.length);
                choices.push(pool.splice(index, 1)[0]);
            }
            choices.forEach((choice) => {
                const card = document.createElement('button');
                card.className = 'upgrade-card';
                card.innerHTML = `<h3>${choice.name}</h3><p>${choice.description}</p>`;
                card.addEventListener('click', () => {
                    applyUpgrade(choice.id);
                    upgradeScreen.classList.add('hidden');
                    gameState.paused = false;
                });
                upgradeOptions.appendChild(card);
            });
            upgradeScreen.classList.remove('hidden');
        }

        function gainXp(amount) {
            player.xp += amount;
            while (player.xp >= player.xpToLevel) {
                player.xp -= player.xpToLevel;
                player.level += 1;
                player.xpToLevel = Math.floor(player.xpToLevel * 1.2);
                openUpgradeScreen();
            }
        }

        function handleMovement(delta) {
            let vx = 0;
            let vy = 0;
            if (keys['w']) vy -= 1;
            if (keys['s']) vy += 1;
            if (keys['a']) vx -= 1;
            if (keys['d']) vx += 1;

            if (pointer.active) {
                const dx = pointer.x - player.x;
                const dy = pointer.y - player.y;
                const distance = Math.hypot(dx, dy);
                if (distance > 8) {
                    vx += dx / distance;
                    vy += dy / distance;
                }
            }

            const magnitude = Math.hypot(vx, vy) || 1;
            const normalizedX = vx / magnitude;
            const normalizedY = vy / magnitude;

            const speed = player.speed * delta;
            player.x += normalizedX * speed;
            player.y += normalizedY * speed;

            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            resolveCollisions(player, player.radius);
        }

        function resolveCollisions(entity, radius) {
            obstacles.forEach((obstacle) => {
                const closestX = Math.max(obstacle.x, Math.min(entity.x, obstacle.x + obstacle.width));
                const closestY = Math.max(obstacle.y, Math.min(entity.y, obstacle.y + obstacle.height));
                const dx = entity.x - closestX;
                const dy = entity.y - closestY;
                const distance = Math.hypot(dx, dy);
                if (distance < radius) {
                    const overlap = radius - distance || 0.1;
                    const nx = dx / distance || 1;
                    const ny = dy / distance || 0;
                    entity.x += nx * overlap;
                    entity.y += ny * overlap;
                }
            });
        }

        function spawnProjectiles(delta) {
            const target = getNearestEnemy();
            if (player.weapons.hunterBolt.level > 0) {
                const weapon = player.weapons.hunterBolt;
                weapon.timer += delta;
                if (weapon.timer >= weapon.cooldown) {
                    weapon.timer = 0;
                    if (target) {
                        fireProjectile({
                            x: player.x,
                            y: player.y,
                            target,
                            speed: 320 * player.projectileSpeed,
                            damage: 8 + weapon.level * 3,
                            color: '#fcd34d',
                            pierce: 1 + Math.floor(weapon.level / 2),
                            radius: 6,
                            lifetime: 3
                        });
                    }
                }
            }
            if (player.weapons.arcaneOrb.level > 0) {
                const weapon = player.weapons.arcaneOrb;
                weapon.timer += delta;
                if (weapon.timer >= weapon.cooldown) {
                    weapon.timer = 0;
                    if (target) {
                        fireProjectile({
                            x: player.x,
                            y: player.y,
                            target,
                            speed: 180 * player.projectileSpeed,
                            damage: 14 + weapon.level * 5,
                            color: '#9b8cff',
                            pierce: 0,
                            radius: 10,
                            lifetime: 3,
                            splash: 40
                        });
                    }
                }
            }
            if (player.weapons.holyBoomerang.level > 0) {
                const weapon = player.weapons.holyBoomerang;
                weapon.timer += delta;
                if (weapon.timer >= weapon.cooldown) {
                    weapon.timer = 0;
                    const angle = Math.random() * Math.PI * 2;
                    projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * 220 * player.projectileSpeed,
                        vy: Math.sin(angle) * 220 * player.projectileSpeed,
                        damage: 10 + weapon.level * 4,
                        color: '#90f7ff',
                        pierce: 3,
                        radius: 8,
                        lifetime: 2.6,
                        boomerang: true
                    });
                }
            }
            if (player.weapons.daggerWave.level > 0) {
                const weapon = player.weapons.daggerWave;
                weapon.timer += delta;
                if (weapon.timer >= weapon.cooldown) {
                    weapon.timer = 0;
                    const daggers = 8 + weapon.level * 2;
                    for (let i = 0; i < daggers; i++) {
                        const angle = (Math.PI * 2 * i) / daggers;
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * 260 * player.projectileSpeed,
                            vy: Math.sin(angle) * 260 * player.projectileSpeed,
                            damage: 6 + weapon.level * 2,
                            color: '#ffb4a2',
                            pierce: 0,
                            radius: 4,
                            lifetime: 2.2
                        });
                    }
                }
            }
        }

        function fireProjectile({ x, y, target, speed, damage, color, pierce, radius, lifetime, splash }) {
            const dx = target.x - x;
            const dy = target.y - y;
            const distance = Math.hypot(dx, dy) || 1;
            projectiles.push({
                x,
                y,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                damage: damage * player.damageMultiplier,
                color,
                pierce,
                radius,
                lifetime,
                splash: splash || 0,
                timer: 0
            });
        }

        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i -= 1) {
                const projectile = projectiles[i];
                projectile.timer = (projectile.timer || 0) + delta;
                if (projectile.boomerang && projectile.timer > projectile.lifetime / 2) {
                    const dx = player.x - projectile.x;
                    const dy = player.y - projectile.y;
                    const distance = Math.hypot(dx, dy) || 1;
                    projectile.vx = (dx / distance) * 240 * player.projectileSpeed;
                    projectile.vy = (dy / distance) * 240 * player.projectileSpeed;
                }
                projectile.x += projectile.vx * delta;
                projectile.y += projectile.vy * delta;

                if (projectile.timer > projectile.lifetime) {
                    projectiles.splice(i, 1);
                    continue;
                }

                if (isProjectileBlocked(projectile)) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j -= 1) {
                    const enemy = enemies[j];
                    const distance = Math.hypot(enemy.x - projectile.x, enemy.y - projectile.y);
                    if (distance < enemy.radius + projectile.radius) {
                        enemy.hp -= projectile.damage;
                        if (projectile.splash) {
                            splashDamage(projectile, enemy, projectile.splash);
                        }
                        if (projectile.pierce > 0) {
                            projectile.pierce -= 1;
                        } else {
                            projectiles.splice(i, 1);
                        }
                        if (enemy.hp <= 0) {
                            handleEnemyDefeat(enemy);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
        }

        function splashDamage(projectile, mainTarget, radius) {
            enemies.forEach((enemy) => {
                if (enemy === mainTarget) return;
                const distance = Math.hypot(enemy.x - projectile.x, enemy.y - projectile.y);
                if (distance < radius) {
                    enemy.hp -= projectile.damage * 0.5;
                }
            });
        }

        function isProjectileBlocked(projectile) {
            return obstacles.some((obstacle) => {
                return projectile.x > obstacle.x && projectile.x < obstacle.x + obstacle.width &&
                    projectile.y > obstacle.y && projectile.y < obstacle.y + obstacle.height;
            });
        }

        function getNearestEnemy() {
            let closest = null;
            let shortest = Infinity;
            enemies.forEach((enemy) => {
                const distance = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                if (distance < shortest) {
                    closest = enemy;
                    shortest = distance;
                }
            });
            return closest;
        }

        function updateEnemies(delta) {
            enemies.forEach((enemy) => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.hypot(dx, dy) || 1;
                let speed = enemy.speed;

                if (enemy.dash && enemy.hp < enemyTypes[enemy.type].hp * 0.6) {
                    speed *= 1.4;
                }

                enemy.x += (dx / distance) * speed * delta;
                enemy.y += (dy / distance) * speed * delta;

                resolveCollisions(enemy, enemy.radius);

                if (enemy.ranged || enemy.caster || enemy.boss) {
                    enemy.attackTimer += delta;
                    if (enemy.attackTimer > (enemy.caster ? 2.8 : enemy.ranged ? 2.4 : 3.2)) {
                        enemy.attackTimer = 0;
                        fireEnemyProjectile(enemy);
                    }
                }

                if (distance < enemy.radius + player.radius) {
                    damagePlayer(enemy.damage);
                }
            });
        }

        function fireEnemyProjectile(enemy) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.hypot(dx, dy) || 1;
            const speed = enemy.caster ? 200 : enemy.ranged ? 180 : 220;
            enemyProjectiles.push({
                x: enemy.x,
                y: enemy.y,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                radius: enemy.caster ? 9 : 6,
                damage: enemy.damage * 0.6,
                color: enemy.caster ? '#7bdff2' : '#f28482',
                lifetime: 3
            });
        }

        function updateEnemyProjectiles(delta) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i -= 1) {
                const projectile = enemyProjectiles[i];
                projectile.x += projectile.vx * delta;
                projectile.y += projectile.vy * delta;
                projectile.lifetime -= delta;

                if (projectile.lifetime <= 0) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                if (isProjectileBlocked(projectile)) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                const distance = Math.hypot(projectile.x - player.x, projectile.y - player.y);
                if (distance < projectile.radius + player.radius) {
                    damagePlayer(projectile.damage);
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function damagePlayer(amount) {
            const mitigated = Math.max(2, amount - player.armor * 0.2);
            player.hp -= mitigated;
            if (player.hp <= 0) {
                endGame(false);
            }
        }

        function updateXp(delta) {
            for (let i = xpOrbs.length - 1; i >= 0; i -= 1) {
                const orb = xpOrbs[i];
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                const distance = Math.hypot(dx, dy);
                if (distance < 120) {
                    orb.x += (dx / distance) * 180 * delta;
                    orb.y += (dy / distance) * 180 * delta;
                }
                if (distance < player.radius + orb.radius) {
                    gainXp(orb.value);
                    xpOrbs.splice(i, 1);
                }
            }
        }

        function handleEnemyDefeat(enemy) {
            spawnXpOrb(enemy.x, enemy.y, enemy.xp);
            if (enemy.boss) {
                endGame(true);
            }
        }

        function updateStage(delta) {
            const stage = stages[gameState.stageIndex];
            if (!stage) return;
            gameState.stageTimer += delta;
            gameState.totalTime += delta;

            if (gameState.stageTimer >= stage.duration) {
                gameState.stageIndex += 1;
                gameState.stageTimer = 0;
                if (gameState.stageIndex >= stages.length) {
                    if (!enemies.some((enemy) => enemy.boss)) {
                        spawnBoss();
                    }
                }
            }

            gameState.difficulty = 1 + gameState.totalTime / 180;
        }

        function updateSpawns(delta) {
            const stage = stages[gameState.stageIndex];
            if (!stage) return;
            stage.spawnTimer = (stage.spawnTimer || 0) + delta;
            const rate = stage.spawnRate / gameState.difficulty;
            if (stage.spawnTimer > rate) {
                stage.spawnTimer = 0;
                spawnEnemy();
            }
        }

        function updateRegen(delta) {
            if (player.armor <= 0) return;
            player.regenTimer += delta;
            if (player.regenTimer > 1.5) {
                player.regenTimer = 0;
                player.hp = Math.min(player.maxHp, player.hp + 2);
            }
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!assets.ready) {
                ctx.fillStyle = '#14141f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f8f6f0';
                ctx.font = '24px "Trebuchet MS"';
                ctx.fillText('Loading sprite pack...', canvas.width / 2 - 140, canvas.height / 2);
                return;
            }
            drawBackground();
            drawObstacles();
            drawXpOrbs();
            drawPlayer();
            drawProjectiles();
            drawEnemies();
            drawEnemyProjectiles();
            drawHUD();
        }

        function drawBackground() {
            ctx.fillStyle = '#14141f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            for (let i = 0; i < 80; i++) {
                ctx.fillRect((i * 37) % canvas.width, (i * 67) % canvas.height, 2, 2);
            }
        }

        function drawObstacles() {
            obstacles.forEach((obstacle) => {
                ctx.save();
                ctx.fillStyle = assets.patterns[obstacle.type] || '#2f2f44';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                if (obstacle.type === 'forest') {
                    const tree = assets.images.treePine || assets.images.treeWillow;
                    if (tree) {
                        const treeSize = Math.min(obstacle.width, obstacle.height) * 0.9;
                        ctx.drawImage(
                            tree,
                            obstacle.x + (obstacle.width - treeSize) / 2,
                            obstacle.y + (obstacle.height - treeSize) / 2,
                            treeSize,
                            treeSize
                        );
                    }
                }
                ctx.restore();
            });
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            const sprite = assets.images.player;
            const size = player.radius * 2.4;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
            ctx.shadowBlur = 6;
            if (sprite) {
                ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
            } else {
                ctx.fillStyle = '#f5d0a6';
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawEnemySprite(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            const sprite = assets.images[enemy.spriteKey];
            const size = enemy.radius * 2.2 * (enemy.boss ? 1.2 : 1);
            ctx.shadowColor = enemy.boss ? 'rgba(255, 183, 3, 0.4)' : 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = enemy.boss ? 10 : 6;
            if (sprite) {
                ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
            } else {
                ctx.fillStyle = '#cbd5f5';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawEnemies() {
            enemies.forEach(drawEnemySprite);
        }

        function drawProjectiles() {
            projectiles.forEach((projectile) => {
                ctx.save();
                ctx.translate(projectile.x, projectile.y);
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(0, 0, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function drawEnemyProjectiles() {
            enemyProjectiles.forEach((projectile) => {
                ctx.save();
                ctx.translate(projectile.x, projectile.y);
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(0, 0, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function drawXpOrbs() {
            xpOrbs.forEach((orb) => {
                ctx.save();
                ctx.translate(orb.x, orb.y);
                const sprite = assets.images.xpFlask;
                if (sprite) {
                    const size = orb.radius * 2.2;
                    ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
                } else {
                    ctx.fillStyle = '#7bf1a8';
                    ctx.beginPath();
                    ctx.arc(0, 0, orb.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function drawHUD() {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
            ctx.fillRect(16, 16, 260, 110);
            ctx.fillStyle = '#f9fafb';
            ctx.font = '14px "Trebuchet MS"';
            ctx.fillText(`Stage: ${stages[Math.min(gameState.stageIndex, stages.length - 1)].name}`, 26, 40);
            ctx.fillText(`Level: ${player.level}`, 26, 62);
            ctx.fillText(`HP: ${Math.round(player.hp)} / ${player.maxHp}`, 26, 84);
            ctx.fillText(`Weapon Power: x${player.damageMultiplier.toFixed(2)}`, 26, 106);

            const xpWidth = 240;
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(16, canvas.height - 26, xpWidth, 10);
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(16, canvas.height - 26, xpWidth * (player.xp / player.xpToLevel), 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.strokeRect(16, canvas.height - 26, xpWidth, 10);

            ctx.restore();
        }

        function update(delta) {
            if (!gameState.running || gameState.paused) return;

            handleMovement(delta);
            updateStage(delta);
            updateSpawns(delta);
            spawnProjectiles(delta);
            updateProjectiles(delta);
            updateEnemies(delta);
            updateEnemyProjectiles(delta);
            updateXp(delta);
            updateRegen(delta);
        }

        function gameLoop(timestamp) {
            if (!gameState.lastTimestamp) {
                gameState.lastTimestamp = timestamp;
            }
            const delta = Math.min(0.05, (timestamp - gameState.lastTimestamp) / 1000);
            gameState.lastTimestamp = timestamp;

            if (gameState.running && !gameState.over && !gameState.won) {
                update(delta);
                drawScene();
                requestAnimationFrame(gameLoop);
            }
        }

        function endGame(victory) {
            gameState.over = !victory;
            gameState.won = victory;
            gameState.running = false;
            endTitle.textContent = victory ? 'Dawn Triumphs' : 'Night Falls';
            endMessage.textContent = victory
                ? 'You shattered the Eclipse Dragon and reclaimed the valley.'
                : 'The hunt ends here. Gather strength and return.';
            endScreen.classList.remove('hidden');
        }

        function startGame() {
            if (!assets.ready) {
                return;
            }
            startScreen.classList.add('hidden');
            endScreen.classList.add('hidden');
            howScreen.classList.add('hidden');
            upgradeScreen.classList.add('hidden');
            resetGameState();
            drawScene();
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        backButton.addEventListener('click', () => {
            endScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });
        howButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            howScreen.classList.remove('hidden');
        });
        closeHowButton.addEventListener('click', () => {
            howScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        loadAssets()
            .then(drawScene)
            .catch((error) => {
                console.error(error);
                assets.ready = true;
                drawScene();
            });
    </script>
</body>
</html>
